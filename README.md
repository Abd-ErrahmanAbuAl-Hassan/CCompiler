C-Style Language Parser
A recursive descent parser for a C-style programming language, written in C#. This parser implements a complete grammar including declarations, statements, expressions, and control flow structures.

Overview
This parser converts source code tokens into an Abstract Syntax Tree (AST) representation using a recursive descent parsing strategy. It supports the full range of C-style language constructs including functions, variables, control flow, and expressions.

Project Structure
text
Parser/
â”œâ”€â”€ ParserCore.cs          # Base parser with token management and utilities
â”œâ”€â”€ ExpressionParser.cs    # Expression parsing with operator precedence
â”œâ”€â”€ StatementParser.cs     # Statement parsing (if, while, for, etc.)
â”œâ”€â”€ DeclarationParser.cs   # Variable and function declarations
â”œâ”€â”€ Parsing.cs            # Main program parsing
â””â”€â”€ Nodes/                # AST node definitions
    â”œâ”€â”€ StatementNodes.cs
    â”œâ”€â”€ ExpressionNodes.cs
    â”œâ”€â”€ DeclarationNodes.cs
    â””â”€â”€ AstNodes.cs
How It Works
1. Token Stream Processing
The parser consumes tokens generated by a scanner (lexer) and builds an AST:

// Example token stream
Token[] tokens = {
    new Token(TokenType.Keyword, "int", 1, 1),
    new Token(TokenType.Identifier, "main", 1, 5),
    new Token(TokenType.Delimiter, "(", 1, 9),
    new Token(TokenType.Delimiter, ")", 1, 10),
    new Token(TokenType.Delimiter, "{", 1, 12),
    // ...
};

var parser = new Parsing(tokens);
ProgramNode ast = parser.Parse();
2. Parsing Phases
Top-level Declarations: Parse global variables and function prototypes

Main Function: Locate and parse the main() function

Post-main Declarations: Parse remaining global declarations

Statement Parsing: Parse function bodies and statements

Expression Parsing: Parse expressions with proper precedence

3. Operator Precedence
The parser implements standard C operator precedence:

() [] .  (postfix)

++ -- (postfix) + - ! ~ * & (prefix)

* / %

+ -

<< >>

< <= > >=

== !=

&

^

|

&&

||

? : (ternary)

= += -= etc. (assignment)

, (comma)

4. Error Recovery
The parser includes robust error recovery with synchronization points:

protected void Synchronize()
{
    // Skip tokens until we find a statement boundary
    while (!IsAtEnd)
    {
        if (Lookahead().Type == TokenType.Delimiter && Lookahead().Value == ";")
        {
            Consume();
            return;
        }
        else if (Lookahead().Type == TokenType.Delimiter && Lookahead().Value == "}")
        {
            return;
        }
        Consume();
    }
}
AST Node Hierarchy
Expression Nodes
NumberExpressionNode - Numeric literals

IdentifierExpressionNode - Variable names

BinaryExpressionNode - Binary operations (+, -, *, etc.)

UnaryExpressionNode - Unary operations (++, --, !, etc.)

CallExpressionNode - Function calls

AssignExpressionNode - Assignment operations

Statement Nodes
BlockStmtNode - Code blocks { ... }

ExprStmtNode - Expression statements

VarDeclStmtNode - Variable declarations

IfStmtNode - If/else statements

WhileStmtNode - While loops

ForStmtNode - For loops

ReturnStmtNode - Return statements

Declaration Nodes
VarDeclNode - Variable declarations

FuncDeclNode - Function declarations

ParamNode - Function parameters

Examples
1. Simple Variable Declaration
int x = 5;
AST Output:

VarDeclStmt[VarDecl[int x = Num[5]]]
2. Function with Parameters

int add(int a, int b) {
    return a + b;
}
AST Output:

FuncDecl[int add(int a, int b) { 
  Return[BinOp[Id[a] + Id[b]]]
}]
3. Control Flow
int main() {
    for (int i = 0; i < 10; i++) {
        if (i % 2 == 0) {
            print(i);
        }
    }
    return 0;
}
AST Output:
FuncDecl[int main() { 
  For[init: VarDeclStmt[VarDecl[int i = Num[0]]], 
      cond: BinOp[Id[i] < Num[10]], 
      inc: Unary[Id[i]++]] {
    If[BinOp[BinOp[Id[i] % Num[2]] == Num[0]]] then {
      Call[Id[print](Id[i])]
    }
  }
  Return[Num[0]]
}]
4. Complex Expression
int result = (x + y) * (z - w) / 2;
AST Output:

VarDeclStmt[VarDecl[int result = BinOp[BinOp[BinOp[(BinOp[Id[x] + Id[y]]) * (BinOp[Id[z] - Id[w]])] / Num[2]]]]
Usage
Basic Integration
csharp
using Scanner;
using Parser;
using Parser.Nodes;

// 1. Tokenize source code
var scanner = new Scanner(sourceCode);
List<Token> tokens = scanner.ScanTokens();

// 2. Parse tokens into AST
var parser = new Parsing(tokens);
ProgramNode program = parser.Parse();

// 3. Check for errors
if (parser.GetErrors().Count > 0)
{
    foreach (var error in parser.GetErrors())
    {
        Console.WriteLine(error);
    }
}
else
{
    // 4. Process AST (e.g., code generation, interpretation)
    Console.WriteLine(program.ToString());
}
Customizing the Parser
Extend the parser to support additional language features:


public class ExtendedParser : DeclarationParser
{
    public ExtendedParser(List<Token> tokens) : base(tokens) { }
    
    // Add support for new statements
    protected override StatementNode ParseControlFlowStatement()
    {
        if (CheckKeyword("switch"))
            return ParseSwitchStatement();
            
        return base.ParseControlFlowStatement();
    }
    
    private SwitchStmtNode ParseSwitchStatement()
    {
        // Implementation for switch statements
    }
}
Features
âœ… Implemented
Data Types: int, float, double, char, void, etc.

Declarations: Variables, arrays, functions

Statements: Blocks, expression statements, control flow

Control Flow: if/else, while, do/while, for

Jump Statements: return, break, continue

Expressions: Arithmetic, logical, relational, assignment

Functions: Declarations, parameters, calls

Error Recovery: Graceful error handling with synchronization

ðŸ”„ Operator Support
Arithmetic: +, -, *, /, %

Relational: ==, !=, <, >, <=, >=

Logical: &&, ||, !

Bitwise: &, |, ^, ~, <<, >>

Assignment: =, +=, -=, *=, /=, etc.

Increment/Decrement: ++, -- (prefix and postfix)

Error Messages
The parser provides informative error messages:

text
Syntax error at 5:12 â€” Expected ';' after expression
Syntax error at 8:3 â€” Missing closing '}'
Syntax error at 12:7 â€” Unexpected token in expression
Syntax error at 15:1 â€” Program must contain a main function
Performance Considerations
The parser is optimized for:

Linear Time Complexity: O(n) where n is the number of tokens

Constant Space Complexity: O(1) additional space (excluding AST)

Minimal Backtracking: Predictive parsing with single token lookahead

Efficient Error Recovery: Quick synchronization to valid parse points

Extending the Parser
Adding New Operators
Add operator to the precedence hierarchy in ExpressionParser.cs

Update IsPrefixOperator() or IsAssignmentOperator() if needed

Add corresponding AST node if necessary

Adding New Statements
Add keyword check in ParseControlFlowStatement()

Implement parsing method

Create corresponding AST node in Nodes/StatementNodes.cs

Adding New Declarations
Extend IsDeclarationStart() to recognize new types

Add parsing logic in DeclarationParser.cs

Create corresponding AST node in Nodes/DeclarationNodes.cs

Testing
Test the parser with various code samples:

public void TestVariableDeclaration()
{
    var tokens = new Scanner("int x = 5;").ScanTokens();
    var parser = new Parsing(tokens);
    var program = parser.Parse();
    
    Assert.AreEqual(0, parser.GetErrors().Count);
    Assert.IsNotNull(program.MainFunction);
}

public void TestFunctionCall()
{
    var tokens = new Scanner("int main() { print(\"Hello\"); }").ScanTokens();
    var parser = new Parsing(tokens);
    var program = parser.Parse();
    
    Assert.AreEqual(0, parser.GetErrors().Count);
    Assert.IsInstanceOf<CallExpressionNode>(
        ((program.MainFunction.Body as BlockStmtNode)
         .Statements[0] as ExprStmtNode).Expression);
}
Contributing
Fork the repository

Create a feature branch

Add tests for new functionality

Ensure all tests pass

Submit a pull request

License
This parser is available under the MIT License. See LICENSE file for details.

Acknowledgments
Inspired by recursive descent parsing techniques

Based on C language grammar specification

Built with education and practical use in mind
